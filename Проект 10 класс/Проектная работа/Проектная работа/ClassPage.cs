using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows.Forms;

namespace Проектная_работа
{
    class Page
    {
        private int type, number; // 1 - меню; 2 - текстовая/иллюстрационная страница; 3 - страница для ввода текста
        private string name;
        private string text;
        private static string[] texts =
            {"    В ходе данной учебной программы вам предлагается для освоения определенный список сортировок, для которых была тщательно подобран учебный материал (включая теорию,  визуализацию работы алгоритмов и непосредственно код). Целью программы является обучение пользователя самостоятельному написанию кода а также его проверка (данная функция пока не реализована за отсутствием системы проверки тестов). Удачи и приятных впечатлений!",
            "    Задачи сортировок – весьма популярный пласт задач в программировании. На вход дается последовательность из n-ого числа записей. Каждая запись состоит из ключа сортировки и сопутствующих данных. Ключ сортировки – это то значение (как правило, числовое), по которому и происходит сортировка последовательности, а сопутствующие данные, как нетрудно догадаться, - это все остальные данные, по сути, в сортировке никак не участвующие. Зачастую запись может не содержать никаких сопутствующих данных.\n\n    Рассмотрим последовательность из 10 записей:\n\n(Москва, Россия, 12 000 000), (Нью-Йорк, США, 8 000 000), (Лондон, Великобритания, 9 000 000), (Париж, Франция, 2 000 000), (Рим, Италия, 3 000 000), (Киев, Украина, 3 000 000), (Пекин, Китай, 21 000 000), (Бразилиа, Бразилия, 2 000 000), (Санкт-Петербург, Россия, 5 000 000), (Рио-де-Жанейро, Бразилия, 6 000 000)\n\n    В ней каждая запись содержит ключ (в данном случае - численность населения) и сопутствующие данные (в данном случае – название города и название страны, в котором он располагается).\n\n    В результате выполнения алгоритма сортировки требуется упорядочить записи в порядке не убывания или не возрастания (в зависимости от конкретной задачи). \n\n    Предоставленную на иллюстрации последовательность можно отсортировать несколькими способами (из-за одинаковых ключей в нескольких записях), однако только один способ сортировки будет считаться устойчивым. Алгоритм сортировки считается устойчивым, если по его окончанию в последовательности сохраняется относительный порядок элементов с одинаковыми ключами. Так, при использовании устойчивого алгоритма сортировки, записи (Рим, Италия, 3 000 000) и (Киев, Украина, 3 000 000) с одинаковыми ключами в 3 000 000 населения будут следовать друг за другом строго в том порядке, в каком они были представлены в изначальной последовательности и не в каком другом.\n\n    Рассмотрим также понятие инверсии. Инверсия – это пара ключей с нарушенным порядком следования. Рассмотрим следующую последовательность ключей, которую нужно отсортировать по не убыванию:\n\n{15, 0, 26, 90, 9, 17, 8}       Итоговая последовательность: {0, 8, 9, 15, 17, 26, 90}\n\n    В ней присутствуют следующие инверсии: (15, 0), (15, 9), (15, 8), (26, 9), (26, 17), (26, 8), (90, 9), (90, 17), (90, 8), (9, 8), (17, 8). В отсортированном массиве число инверсий равно нулю, что и является нашей целью при реализации любого алгоритма сортировки.\nВычислительная сложность алгоритма — понятие в информатике и теории алгоритмов, обозначающее функцию зависимости объёма работы, которая выполняется некоторым алгоритмом, от размера входных данных. Говоря проще, сложность алгоритма – это то, какую работу придется выполнить машине (компьютеру), для осуществления того или иного алгоритма. Сложность обозначается как O(N), где N в нашем случае – это длина входной последовательности.",
            "    Сортировка пузырьком – пожалуй, самый интуитивно понятный и простой из всех алгоритмов сортировки.\n\n    Идея сортировки пузырьком: Попарно сравниваем соседние ключи, проходя через весь массив до тех пор, пока тот не будет отсортирован. Так, каждая перестановка элементов массива будет уменьшать количество инверсий на 1.\n\n    Начиная с 1-го элемента, сравниваем его с предыдущим. Если находим несоответствие – то есть ситуацию, в которой i-й элемент меньше элемента i-1 (и наоборот для сортировки по не возрастанию), - то меняем эти элементы местами и идем дальше, пока не дойдем до конца массива. Дойдя до конца, начинаем сначала – и это повторяется до тех пор, пока массив не будет отсортирован, то есть в течение одного из проходов не один элемент не поменяет своего местоположения (это осуществляется при помощи обычной переменной класса bool, которую мы назначаем true в начале каждой итерации, а при наличии перестановки назначаем false).\n\n    Особенности сортировки пузырьком:\n\n - Легка в понимании и реализации.\n\n - Устойчива.\n\n - Сложность в наилучшем случае – O(N), в наихудшем – O(N^2).\n\n - Для реализации алгоритма не требуется создавать дополнительные массивы, требуется всего 3-4 переменные.",
            "    Следующим по счету в нашей учебной программе будет сортировка вставками. Сортировка вставками – довольно несложно реализуемый алгоритм сортировки.\n\n    Мы начинаем с 1-го по счету элемента в массиве (не забывайте, что в массивах отсчет элементов начинается с 0-го) и сравниваем его с предыдущим до тех пор, пока не найдем нужную нам позицию – то есть из рассмотренных первых двух элементов он должен стоять на своем месте, эти 2 элемента должны быть отсортированы между собой. Достигая этого, мы двигаемся дальше. Каждая из n-1 (где n – длина массива) итераций содержит в себе цикл, в котором элемент изначального массива под номером i (в данном цикле используется индекс j, изначально j=i) сравнивается с предыдущим, и они меняются местами, если предыдущий больше, а j уменьшается на 1. Так продолжается до тех пор, пока j>0, либо, пока предыдущий элемент под номером j-1 не окажется меньше элемента под номером j. Так, по окончанию каждого из внутренних циклов, мы получаем отсортированный фрагмент массива.\n\n    Теперь вам к рассмотрению предлагается визуализация данной сортировки, а также непосредственно написанный код, посмотреть которые вы можете по нажатию на соответствующие кнопки в нижней части экрана.\n\n    Особенности сортировки вставками:\n\n - Сложность в лучшем случае – O(N), в худшем – O(N^2), однако если массив частично упорядочен, то его сложность будет меньше, чем в случае сортировки пузырьком.\n\n - Алгоритм устойчив.\n\n - Как и в алгоритме сортировки пузырьком, для реализации алгоритма не требуется создавать дополнительные массивы, размеры которых зависели бы от размеров начальной последовательности.\n\n - Позволяет отсортировать массив при динамическом добавлении новых элементов. Так называемый, online-алгоритм сортировки, что в определенных ситуациях может быть полезным.",
            "    И последним алгоритмом сортировки в моей учебной программе будет алгоритм сортировки Шелла. В процессе описания работы алгоритма сортировки Шелла, часто будут встречаться отсылки на алгоритм сортировки пузырьком, так что прежде чем приступать к его изучению, пожалуйста, удостоверьтесь, что понимаете принцип его работы.\n\n    Итак, алгоритм сортировки Шелла – это довольно легкий в понимании, но далеко не настолько легкий, скорее даже сложный, в реализации алгоритм сортировки. По сути, сортировка Шелла – это усовершенствованная сортировка пузырьком. Вся разница заключается в том, что если в случае с пузырьком, мы сравниваем между собой лишь соседние элементы последовательности, то в случае сортировки Шелла мы сравниваем элементы, находящиеся друг от друга на определенном расстоянии. Например, рассмотрим сортировку последовательности с перестановкой местами элементов, находящихся на расстоянии 4.\n\n    {12, 9, 7, 6, 5, 4, 3, 1} Количество инверсий – 28.\n    Переставим местами элемент номер 0 и элемент номер 4 и получим следующую последовательность: {5, 9, 7, 6, 12, 4, 3, 1} В ней количество инверсий – 21.\n    Так, всего за одну перестановку, мы уменьшили число инверсий на 7 (а не на 1, как при сортировке пузырьком).\n\n    Пройдя весь массив, мы уменьшаем шаг (расстояние между сравниваемыми элементами), чтобы переставить местами те элементы с неправильным порядком следования, который находятся ближе текущего шага относительно друг друга.\n\n    Однако как мы уменьшаем этот шаг? Его надо уменьшать не абы как, а по определенной последовательности. Сам Дональд Шелл, придумавший данный алгоритм, предлагал выбирать шаги в виде убывающей геометрической прогрессии: N/2, N/4, N/8, …, 1. Однако, как позже выяснилось, данная последовательность является далеко не самой эффективной. Мы рассмотрим сортировку Шелла с последовательностью h={1, 4, 13, …}, в которой h(n)= h(n-1)*3+1, считающуюся одной из самых эффективных. Однако идеальная последовательность до сих пор не была найдена.\n\n    Особенности сортировки Шелла:\n\n - Сложность алгоритма в лучшем случае – O(N), в худшем – зависит от последовательности (в нашем случае – O(N^3/2), однако ее можно снизить до O(N^4/3)).\n\n - Алгоритм неустойчив, а значит может поменять порядок элементов с одинаковыми ключами.\n\n - Число дополнительных переменных не зависит от размера.\n\n - Алгоритм конкурентоспособен популярным алгоритмам сортировки при не очень высоких N.",
            "    Поздравляем! Вы успешно прошли нашу учебную программу. Вы можете пройти ее снова, перейдя в меню или на конкретную страницу, либо закрыть ее по нажатии на одноименную кнопку. Спасибо за уделенное нам время, надеемся, оно не было потрачено впустую. "};
        public Page(int type, int number, string name)
        {
            this.name = name;
            this.type = type;
            this.number = number;
            text = texts[number];
        }
        public void Show()
        {
            switch (type)
            {
                case 1:
                    //MessageBox.Show("Это страница типа menu");
                    break;
                case 2:
                    //MessageBox.Show("Это страница типа текст/иллюстрация");
                    break;
                case 3:
                    //MessageBox.Show("Это страница типа ввод текста");
                    break;
            }
        }
        public string Name
        {
            get
            {
                return name;
            }
            set
            {
                name = value;
            }
        }
        public int Number
        {
            get
            {
                return number;
            }
            set
            {
                try
                {
                    if (value < 0)
                        throw new Exception();
                    else
                        number = value;
                }
                catch
                {
                    MessageBox.Show("Ошибка при введении номера страницы");
                }
            }
        }
        public int Type
        {
            get
            {
                return type;
            }
            set
            {
                try
                {
                    if (value != 1 && value != 2 && value != 3)
                        throw new Exception();
                    else
                        type = value;
                }
                catch
                {
                    MessageBox.Show("Ошибка при введении типа страницы");
                }
            }
        }
        public void Info()
        {
            switch (type)
            {
                case 1:
                    MessageBox.Show("Это страница с меню. Здесь вы можете увидеть список доступных заданий. Нажмите на кнопку 'Далее', чтобы начать выполнение заданий с начала списка или выберите нужное вам задание и кликните по его названию", "Информация");
                    break;
                case 2:
                    {
                        if (number == 1)
                            MessageBox.Show("Это страница с теоретической информацией. Нажмите 'Далее', чтобы перейти к конкретной сортировке", "Информация");
                        else
                            MessageBox.Show("Это страница с теоретической информацией. Нажмите 'Начать сортировку', чтобы просмотреть ее визуализацию или 'Посмотреть код', чтобы увидеть код данной сортировки, написанный на алгоритмическом языке", "Информация");
                        break;
                    }
            }
        }
        public string Text
        {
            get
            {
                return text;
            }
            set
            {
                text = value;
            }
        }
    }
    
}
